# Метрики JVM. Какие есть и как их читать.
## Вступление
## Где искать метрики JVM?
В JVM есть довольно большое количество разных метрик, которые она собирает по в ходе своей работы. И большинство из них публикуются как атрибуты бинов JMX (Java Menegement eXtensions). 

### JConsole

Для того, чтобы найти эти бины в работающем приложении и изучить их можно воспользоваться несколькими способами. Самый простой из них - воспользоваться утилитой из стандартной поставки OpenJDK - jconsole.

Если её запустить, то мы увидим окно с диалогом подключения в котором мы можем выбрать один из запущенных процессов:

![[jconsole_connect.png]]
После выбора необходимого процесса открывается окно с несколькими графиками:

![[jconsole_graphics.png]]
Так же Некоторую информацию можно увидеть на соседних вкладках.

Память:

![[jconsole_memory.png]]
Потоки:

![[jconsole_threads.png]]
Загрузка классов:

![[jconsole_classes.png]]
А так же общая информация о JVM:

![[jconsole_summary.png]]
Вся эта информация берётся как раз из JMX. Чтобы увидет эту информацию в сыром виде нам нужна последняя вкладка - MBeans (Management Beans). Так называются бины JMX.

![[jconsole_mbeans.png]]
Тут слева можно увидеть дерево со сгруппированным списком доступных в текущем приложении бинов. Если выбрать один из бинов и у него выбрать раздел с аттрибутами, то справа отобразятся все аттрибуты бина с их значениями.

Основные метрики JVM можно найти в разделе `java.lang`. Но ещё немного можно найти и в разделе `java.nio`.

Конкреные метрики и их анализ рассмотрим чуть позже.

### JMC

В качестве ещё одного интсрумента для визуальной работы с JMX бинами можно рассмотреть такую утилиту, как JMC (Java Mission Control). Она уже не поставляется вместк с OpenJDK. Но тоже является open source и можно найти несколько собранных версий от разных вендоров. В основном она используется для анализа записей JFR (Java Flight Recorder), но так же позволяет работать с JMX.

![[jmc_bmeans_system.png]]

Её преимущество заключается в том, что в отличии от JConsole, она представляет данные не в голом виде, а в человекочитаемой форме. Так же она умеет выводить подробную информацию по каждому атрибуту, если предварительно настроить отображение соответствующей колонки в таблице со значениями атрибутов.

### SJK
Так же значения атрибутов JMX бинов можно получать из командной строки с помощью утилиты [sjk](https://github.com/aragozin/jvm-tools) от Алексея Рагозина:

```bash
java -jar sjk.jar mx \
    --pid 30942 \
    --bean java.lang:type=OperatingSystem \
    --attribute ProcessCpuLoad \
    --get
```

Где:
- **30942** - PID Java приложения
- **java.lang:type=OperatingSystem** - имя, под которым зарегистрирован бин в JMX
- **ProcessCpuLoad** - имя аттрибута, который мы хотим посмотреть

### JMX API
Ну и конечно можно получить доступ к этим же значениям программно. 

Для доступа к JMX бинам от JVM можно воспользоваться классом `java.lang.management.ManagementFactory`, который имеет ряд статических геттеров, возвращяющих объекты всех доступных бинов JVM. Например нагрузку на процессор, порождаемую нашим приложением можно получить следующим образом:

```java
import com.sun.management.OperatingSystemMXBean;

int getCpuCount() { 
    OperatingSystemMXBean bean = (OperatingSystemMXBean) ManagementFactory
        .getOperatingSystemMXBean();
    int cpuCoreCount = bean.getProcessCpuLoad();
}
```

## Как собирать метрики?
Прежде чем мы приступим к детальному разбору метрик, давайте посмотрим как их можно собирать для анализа.
Существует много разных средст сбора этих метрик. Фактически каждая система мониторинга предоставляет то или иное решение. Но я на своей практике работал с двумя подходами.
### jmxtrans
Первый из таких подходов - использовать утилиту [jmxtrans](https://github.com/jmxtrans/jmxtrans). Этот инструмент, путём нехитрой конфигурации позволяет получать доступ к любым JMX бинам нескольких приложений сразу, извлекать из них информацию и складывать последнюю в большой спектр хранилищ. Хоть Graphit, хоть Prometheus, хоть что угодно ещё.

![[jmxtrans_usage_diagram.png]]

При этом достаточно задать простую конфигурацию:

```json
{
  "servers": [{
    "host" : "application",
    "port" : "1099",
    "runPeriodSeconds": "60",
    "queries": [{
      "obj": "java.lang:type=MemoryPool,name=*",
      "attr": ["Usage"],
      "outputWriters": [{
        "@class": "com.googlecode.jmxtrans.model.output.GraphiteWriter",
        "host": "carbon",
        "port": "2003"
      }]
    }]
  }]
}
```

И запустить jmxtrans.

Плюсы такого подхода:
- Простота настройки
- Универсальность
- Нет необходимости изменять приложение

Минусы:
- Безопасность: приходится выставлять по сети весь JMX, который предоставляет слишком много возможностей.
- Может обрабатывать не очень большое количество приложений
- Для выставления своих метрик приложения приходится писать полноценные JMX бины, что иногда не так-то просто

### Micrometer

Ещё одним подходом к снятию метрик является встраивание в приложение библиотеки, поставляющей только необходимые метрики.

Одной из таких библиотек является [Micrometer](https://micrometer.io/).  Умеет: 
- собирать метрики JVM 
- предоставляет простой и понятный API для сбора метрик приложения
- Выставлять метрики по HTTP протоколу в одном из множества форматов

Причём в случае со Spring Boot его даже подключать специально не надо. Он идёт из коробки.

Плюсы:
- Безопасность: в сеть выставляется только нужное
- Идёт из коробки со Spring Boot
- Простота создания своих метрик
- Предоставляет метрики, которые нельзя извлечь из JMX напрямую

Минусы:
- По умолчанию выставлены не все метрики JVM
- Без Spring Boot надо модифицировать приложение для подключения метрик
- Требуется дополнительное приложение для переноса метрик в хранилище

### Выбор подхода

Т.о., если у вас уже есть приложение или большой набор приложений и вам нужно максимально быстро начать собирать метрики, то может быть полезен jmxtrans.

Если у вас Spring Boot или другой фреймворк и есть время на внедрение метрик, то лучше использовать Micrometer как более безопасное и легкорасширяемое средство.

## Анализ метрик
С тем как собирать метрики разобрались, теперь давайте перейдём к их анализу.

Все метрики можно условно разделить на два типа: мгновенные и накапливающиеся. 

### Мгновенные метрики
JVM предоставляет много метрик такого типа. Я не буду рассматривать все, а пройдусь только по самым основным.

#### Нагрузка на CPU
Начнём с нагрузки на CPU. JVM предоставляет две метрики в бине `java.lang.OperatingSystem`:

- `ProcessCpuLoad` - Нагрузка на процессор, создаваемая приложением, в котором смотрится метрика
- `SystemCpuLoad` - Общая нагрузка на всю OS

![[jmc_cpu_metrics.png]]
Они принимают значения от 0 до 1 в зависимости от процента нагрузки на CPU.

Метрика `ProcessCpuLoad` может быть интересна для оценки причин тормозов приложения. Если приложение тормозит, а нагрузка на CPU низкая, то скорее всего проблемы в чём-то следующем:

- Закончился пулл подключений JDBC
- Вызовы другого сервиса, который тоже медленно отвечает
- Чрезмерно большое количество вызовов других сервисов
- Проблемы с синхронизацией приложения

Первые три варианта могут быть уточнены другими метриками, которые уже не относятся к JVM, но по хорошему тоже должны сниматься. Такими, как использование JDBC подключений или время ответа вызываемых сервисов.

Последний вариант уже придётся диагностировать через JFR или ещё какими-то средствами.

#### Занимаемая память
Если же нам нужно посмотреть как у приложения обстоят дела с занимаемой памятью, то всё становится сложнее.

Дело в том, что у JVM много разных разделов памяти и каждый из них считается по отдельности. В первом приближении всю используемую JVM память можно разделить на две большие категории. Память кучи (heap), и память вне кучи. 

![[jmc_memory.png]]
В бине `java.lang.Memoty` есть два аттрибута:
- HeapMemotyUsage - содержит информацию о памяти, занимаемой хипом
- NonHeapMemotyUsage - содержит информацию о памяти, занимаемой всеми остальными регионами

При этом каждый из этих аттрибутов содержит не одно какое-то конкретное значение, а целый набор значений. И такой набор содержится во всех аттрибутах, связанных с памятью:

- used - сколько памяти реально используется в данный момент
- init - сколько памяти было выделено в момент старта JVM. Например для хипа настраивается через параметр запуска -Xms.
- max - максимально разрешённый для JVM объём памяти, установленный при запуске. Например для хипа настраивается через параметр запуска -Xmx.
- commited - сколько памяти зарезервировано у OS. Резервируется обычно с некоторым запасом.

Т.о. уже даже на этом уровне мы имеем по факту 8 метрик. 

Но всё становится куда интереснее, если мы попытаемся эту информацию детализировать. Например для того, чтобы детализировать информацию по хипу нам необходимо знать с каким именно сборщиком мусора запущено приложение, т.к. от этого зависит какие регионы хипа будут созданы и с какими именами. Так, например для сборщика мусора G1 будут созданы регионы:
- G1 Eden Space
- G1 Susrvivor Space
- G1 Old Gen

Именно так и будут называться бины JMX, расположенные в разделе `java.lang.MemoryPool`:

![[jmc_g1_eden.png]]
В каждом из таких бинов есть атрибут `Usage`, содержащий информацию о памяти этого региона.

Данных бинов три, т.к. G1 - сборщик мусора с поколениями. Все новые объекты создаются в Eden. Те которые переживают первую сборку мусора попадают в Survivor. Если объекты переживают последующие сборки мусора, то они попадают в Old Gen.

И в следствии того, что каждый атрибут метрик памяти имеет по четыре значения, то получаем, что для хипа у нас аж 12 метрик, в которых уже легко заблудиться.

И анализировать их тоже можно по разному. Например можно вывести Eden, Susrvival и Old Gen на отдельные графики:

![[grafana_memory_heap_separate.png]]

Но как по мне, так это малоинформативно. В силу того, что наибольший интерес представляет сколько все эти три региона памяти занимают от общего хипа. Гораздо интереснее совместить Usage всех трёх регионов в одном графике в режиме stack и добавить отсечку в виде общего выделенного на JVM хипа:

![[grafana_memory_heap_single.png]]

В таком виде гораздо легче оценить насколько приложению хватает хипа.

Аналогично можно вывести на графики метрики, которые присутствуют в бинах в разделе `java.lang.MemoryPool`, которые относятся к NonHeap разделам. Это:

- CodeHeap 'non-nmethods' - служебная память JIT компилятора
- CodeHeap 'profiled nmethods' - машинный код, скомпилироваммый C1
- CodeHeap 'non-profiled nmethods' - машинный код, скомпилированный C2
- Compressed Class Space - распарсенные class файлы
- Metaspace - служебные данные JVM

Но и это ещё не вся NonHeap память. Ещё приложение может использовать `java.nio.ByteBuffer` как просто DirectByteBuffer, так и MappedByteBuffer.

Чтобы посмотреть объём памяти занимаемой этими буферами нам понадобятся два соответствующих бина из раздела `java.nio.BufferPool`:

- direct
- mapped

![[jmc_nio_direct.png]]
У каждого из этих бинов есть арртибуты:

- MemoryUsed - сколько памяти занимают буфферы данного типа
- Count - сколько всего буфферов такого типа создано

Но и это ещё не вся NonHeap память. Дело в том, что каждый поток имеет свой выделенный стек. И это тоже занимаемая память. Так же каждый GC имеет свои служебные данные. А ещё приложение может использовать нативные вызовы, которые в свою очередь тоже могут использовать какое-то количество памяти. К сожалению доступных JMX бинов, трекающх этот тип памяти не существует и по этому вся такая память остаётся в серой зоне для мониторинга.

#### Память до/после GC
В JVM есть ещё некоторое количество интересных метрик памяти, которые могут давать прогноз об утечках памяти в приложении. Правда запрятаны они довольно далеко. Для G1 они находятся они в бине `G1 Old Generation` в разделе `java.lang.GarbageCollection`. Далее у этого бина нас интересует составной аттрибут `LastGcInfo`, у которого есть поле `memoryUsageAfterGc`. Это поле представляет из тебя мапу, где в качестве ключа используется строка с именем региона памяти, а в качестве значения - знакомый нам тип данных с информацией о памяти. Для наших целей диагностики находим запись с ключом `G1 Old Gen` и смотрим на поле `used`:

![[jmc_memory_after_gc.png]]
Это значение интересно тем, что оно обновляется только после сборки мусора старого поколения. Следовательно если оно постоянно растёт, то мы можем с уверенностью сказать, что в старом поколении постоянно копятся объекты, которые не освобождаются. А значит очень велика вероятность того, что в приложении присутствует утечка памяти и мы можем начинать предпринимать меры до того, как приложение начнёт из-за этого тормозить выдавать OOM.

Как можно видеть на слайде есть ещё довольно много метрик на ту же тему по разным регионам памяти. Причём есть отдельные наборы метрик как для сборки старого поколения, так и для молодого. Так что тут тоже есть в чём покопаться, но это уже выходит за рамки данного доклада.

### Накапливаемые метрики
Теперь давайте посмотрим какие есть накапливаемые метрики и как их можно анализировать.

#### Сборка мусора
Наиболее интересными накапливающимися метриями являются показания сборщика мусока. Мы уже вскользь касались бинов с этими метриками чуть ранее. Для G1 это бины
- G1 Young Generation
- G1 Old Generation

в разделе `java.lang.GarbageCollector`.

![[jmc_gc_oldgen.png]]
В каждом из этих бинов есть по два аттрибута:
- CollectionCount - сколько раз запускалась сборка молодого или старого поколения
- CollectionTime - сколько суммарно по времени работал сборщик старого или молодого поколения

Анализировать данные метрики как есть большого смысла не имеет, потому как мы просто увидим постепенно увеличивающиеся значения:

![[grafana_gc_total.png]]

Но гораздо интереснее видеть не общее количество запусков GC, а то, сколько раз в секунду/минуту запускалась сборка мусора и сколько времени она длилась:

![[grafana_gc_rate.png]]

В таком виде мы уже можем оценить насколько активно работает GC.

Запрос в Prometheus может выглядеть примерно так:

```
rate(jvm_gc_seconds{application="$application",instance="$instance"}[1m])
```

В результате правый график нужно читать как: "сколько времени из прошедшей минуты было потрачено на работу GC". Это может быть несовсем удобно воспринимать. По этому запрос можно переписать следующим образом:

```
rate(jvm_gc_seconds{application="$application",instance="$instance"}[1m])*100/1m
```

Тогда мы будем видеть нагрузку на GC в процентах от общего времени.

![[grafana_gc_load.png]]

По поводу данной метрики существует такая эвристика, что если она становмтся больше 10%, то приложение пора спасать. Скорее всего у него:
- Недостаточно хипа
- Слишком быстро выделяются новые объекты



